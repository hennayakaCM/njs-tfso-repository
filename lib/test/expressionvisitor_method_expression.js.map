{"version":3,"file":"expressionvisitor_method_expression.js","sourceRoot":"","sources":["expressionvisitor_method_expression.ts"],"names":[],"mappings":";AAAA,MAAY,MAAM,WAAM,QAAQ,CAAC,CAAA;AACjC,MAAY,IAAI,WAAM,oCAAoC,CAAC,CAAA;AAE3D,QAAQ,CAAC,2DAA2D,EAAE;IAClE,IAAI,OAA+B,EAC/B,IAAsB,CAAC;IAE3B,UAAU,CAAC;QACP,OAAO,GAAG,IAAI,IAAI,CAAC,iBAAiB,CAAC;IACzC,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,sCAAsC,EAAE;QACvC,IAAI,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,GAAW,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;QAE9D,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,6BAA6B,CAAC,CAAC;QAClF,MAAM,CAAC,EAAE,CAA0B,IAAK,CAAC,IAAI,IAAI,SAAS,EAAE,gCAAgC,CAAC,CAAC;QAC9F,MAAM,CAAC,EAAE,CAA0B,IAAK,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC,EAAE,uBAAuB,CAAC,CAAC;QAC1F,MAAM,CAAC,EAAE,CAA0B,IAAK,CAAC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,iCAAiC,CAAC,CAAC;IAC/H,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,uDAAuD,EAAE;QACxD,IAAI,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,GAAW,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;QAEzE,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,6BAA6B,CAAC,CAAC;QAClF,MAAM,CAAC,EAAE,CAA0B,IAAK,CAAC,IAAI,IAAI,UAAU,EAAE,iCAAiC,CAAC,CAAC;QAChG,MAAM,CAAC,EAAE,CAA0B,IAAK,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC,EAAE,yBAAyB,CAAC,CAAC;QAC5F,MAAM,CAAC,EAAE,CAA0B,IAAK,CAAC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,iCAAiC,CAAC,CAAC;QAEvH,MAAM,CAAC,EAAE,CAA0B,CAA0B,IAAK,CAAC,MAAM,CAAE,CAAC,IAAI,IAAI,SAAS,EAAE,gCAAgC,CAAC,CAAC;QACjI,MAAM,CAAC,EAAE,CAA0B,CAA0B,IAAK,CAAC,MAAM,CAAE,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC,EAAE,uBAAuB,CAAC,CAAC;QAC7H,MAAM,CAAC,EAAE,CAA0B,CAA0B,IAAK,CAAC,MAAM,CAAE,CAAC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,iCAAiC,CAAC,CAAC;IAClK,CAAC,CAAC,CAAA;AACN,CAAC,CAAC,CAAC","sourcesContent":["import * as assert from 'assert';\r\nimport * as Expr from './../expressions/expressionvisitor';\r\n\r\ndescribe(\"When using ExpressionVisitor for method Lambda expression\", () => {\r\n    var visitor: Expr.ExpressionVisitor,\r\n        expr: Expr.IExpression;\r\n\r\n    beforeEach(() => {\r\n        visitor = new Expr.ExpressionVisitor;\r\n    })\r\n\r\n    it(\"it should return a method expression\", () => {\r\n        expr = visitor.visitLambda((str: string) => str.indexOf(\"a\"));\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Method, \"Expected a MethodExpression\");\r\n        assert.ok((<Expr.IMethodExpression>expr).name == \"indexOf\", \"Expected method name 'indexOf'\");\r\n        assert.ok((<Expr.IMethodExpression>expr).parameters.length == 1, \"Expected one argument\");\r\n        assert.ok((<Expr.IMethodExpression>expr).caller.type == Expr.ExpressionType.Identifier, \"Expected a identifier as caller\");\r\n    })\r\n\r\n    it(\"it should return a method expression for nested calls\", () => {\r\n        expr = visitor.visitLambda((str: string) => str.indexOf(\"a\").toString());\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Method, \"Expected a MethodExpression\");\r\n        assert.ok((<Expr.IMethodExpression>expr).name == \"toString\", \"Expected method name 'toString'\");\r\n        assert.ok((<Expr.IMethodExpression>expr).parameters.length == 0, \"Expected zero arguments\");\r\n        assert.ok((<Expr.IMethodExpression>expr).caller.type == Expr.ExpressionType.Method, \"Expected a new method as caller\");\r\n\r\n        assert.ok((<Expr.IMethodExpression>((<Expr.IMethodExpression>expr).caller)).name == \"indexOf\", \"Expected method name 'indexOf'\");\r\n        assert.ok((<Expr.IMethodExpression>((<Expr.IMethodExpression>expr).caller)).parameters.length == 1, \"Expected one argument\");\r\n        assert.ok((<Expr.IMethodExpression>((<Expr.IMethodExpression>expr).caller)).caller.type == Expr.ExpressionType.Identifier, \"Expected a identifier as caller\");\r\n    })\r\n});\r\n"]}