{"version":3,"file":"expressionvisitor_logical_expression.js","sourceRoot":"","sources":["../../test/expressionvisitor_logical_expression.ts"],"names":[],"mappings":"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","sourcesContent":["import assert = require('assert');\r\nimport * as Expr from './../lib/expressions/expressionvisitor';\r\n\r\ndescribe(\"When using ExpressionVisitor for logical Lambda expression\", () => {\r\n    var visitor: Expr.ExpressionVisitor,\r\n        expr: Expr.IExpression;\r\n\r\n    beforeEach(() => {\r\n        visitor = new Expr.ExpressionVisitor;\r\n    })\r\n\r\n    it(\"it should return a logical operation\", () => {\r\n        expr = visitor.visitLambda(() => 5 && 2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n        assert.ok((<Expr.IBinaryExpression>expr).left.type == Expr.ExpressionType.Literal, \"Expected a literal at left side\");\r\n        assert.ok((<Expr.IBinaryExpression>expr).right.type == Expr.ExpressionType.Literal, \"Expected a lteral at right side\");\r\n        assert.ok((<Expr.ILiteralExpression>(<Expr.IBinaryExpression>expr).left).value == 5, \"Expected number 5 at left side\");\r\n        assert.ok((<Expr.ILiteralExpression>(<Expr.IBinaryExpression>expr).right).value == 2, \"Expected number 5 at right side\");\r\n    });\r\n\r\n    it(\"it should handle logical operation for and\", () => {\r\n        expr = visitor.visitLambda(() => 5 && 2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.And, \"Expected a binary operation of and\");\r\n    });\r\n\r\n    it(\"it should handle logical operation for or\", () => {\r\n        expr = visitor.visitLambda(() => 5 || 2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.Or, \"Expected a binary operation of or\");\r\n    });\r\n\r\n    it(\"it should handle logical operation for equal\", () => {\r\n        expr = visitor.visitLambda(() => <number>5 == <number>2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.Equal, \"Expected a binary operation of equal\");\r\n    });\r\n\r\n    it(\"it should handle logical operation for not equal\", () => {\r\n        expr = visitor.visitLambda(() => <number>5 != <number>2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.NotEqual, \"Expected a binary operation of not equal\");\r\n    });\r\n\r\n    it(\"it should handle logical operation for greater than\", () => {\r\n        expr = visitor.visitLambda(() => 5 > 2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.Greater, \"Expected a binary operation of greather than\");\r\n    });\r\n\r\n    it(\"it should handle logical operation for greater or equal than\", () => {\r\n        expr = visitor.visitLambda(() => 5 >= 2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.GreaterOrEqual, \"Expected a binary operation of greater or equal than\");\r\n    });\r\n\r\n    it(\"it should handle logical operation for lesser\", () => {\r\n        expr = visitor.visitLambda(() => 5 < 2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.Lesser, \"Expected a binary operation of lesser\");\r\n    });\r\n\r\n    it(\"it should handle logical operation for or\", () => {\r\n        expr = visitor.visitLambda(() => 5 <= 2);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a LogicalExpression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.LesserOrEqual, \"Expected a binary operation of lesser or equal than\");\r\n    });\r\n});\r\n"]}