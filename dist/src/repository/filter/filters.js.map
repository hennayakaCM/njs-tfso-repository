{"version":3,"file":"filters.js","sourceRoot":"","sources":["../../../../src/repository/filter/filters.ts"],"names":[],"mappings":";AAAA,uBAAgC,UAAU,CAAC,CAAA;AAG3C,iCAAiC,sCAAsC,CAAC,CAAA;AACxE,+BAA+E,oCAAoC,CAAC,CAAA;AASpH;IAGI,iBAAY,SAAmC;QAAE,oBAAoB;aAApB,WAAoB,CAApB,sBAAoB,CAApB,IAAoB;YAApB,mCAAoB;;QAF7D,YAAO,GAAmB,EAAE,CAAC;QAIjC,IAAI,MAAM,GAAG,IAAI,mCAAgB,CAAC,SAAS,CAAC,EACxC,OAAO,GAAG,IAAI,+BAAc,EAAE,CAAC;QAEnC,IAAI,UAAU,GAAG,OAAO,CAAC,WAAW,OAAnB,OAAO,GAAa,SAAS,SAAK,UAAU,EAAC,CAAC;QAE/D,EAAE,CAAC,CAAC,OAAO,CAAC,UAAU,IAAI,IAAI,CAAC,CAAC,CAAC;YAC7B,EAAE,CAAC,CAAC,UAAU,IAAI,IAAI,IAAI,UAAU,CAAC,IAAI,IAAI,+BAAc,CAAC,OAAO,CAAC;gBAChE,IAAI,CAAC,OAAO,GAAG,eAAM,CAAC,KAAK,CAAqB,UAAU,CAAC,CAAC;QACpE,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;QACjD,CAAC;IACL,CAAC;IAED,sBAAW,2BAAM;aAAjB;YACI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;QACxB,CAAC;;;OAAA;IAEM,0BAAQ,GAAf;QACI,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,CAAC;YACzB,MAAM,CAAC,IAAI,KAAK,EAAmB,CAAC;QAExC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG;YACvC,MAAM,CAAC,IAAI,eAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QACvD,CAAC,CAAC,CAAC,QAAQ,CAAC;IAChB,CAAC;IAEM,iCAAe,GAAtB;QACI,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC;YACxB,MAAM,CAAC,IAAI,KAAK,EAAmB,CAAC;QAExC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG;YACvC,IAAI,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAC,QAAQ;gBACxC,GAAG,CAAC,CAAa,UAAU,EAAV,KAAA,CAAC,CAAC,QAAQ,EAAV,cAAU,EAAV,IAAU,CAAC;oBAAvB,IAAI,IAAI,SAAA;oBACT,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC;wBAAC,MAAM,CAAC,IAAI,CAAC;iBAAA;gBAE9H,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC,CAAC,CAAA;YAEF,MAAM,CAAC,IAAI,eAAM,CAAC,QAAQ,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC,QAAQ,CAAA;IACf,CAAC;IACL,cAAC;AAAD,CAAC,AA9CD,IA8CC;AA9CY,eAAO,UA8CnB,CAAA","sourcesContent":["import { IFilter, Filter } from './filter';\nimport { IFilterCriteria, FilterCriteria } from './filtercriteria';\n\nimport { LambdaExpression } from './../../expressions/lambdaexpression';\nimport { ReducerVisitor, Expression, ExpressionType, ILogicalExpression } from './../../expressions/reducervisitor';\n\nexport interface IFilters {\n    groups: Array<IFilter>\n\n    getUnion(): Array<IFilterCriteria>\n    getIntersection(): Array<IFilterCriteria>\n}\n\nexport class Filters<TEntity> implements IFilters {\n    private _groups: Array<IFilter> = [];\n\n    constructor(predicate: (it: TEntity) => boolean, ...parameters: any[]) {\n\n        var lambda = new LambdaExpression(predicate),\n            visitor = new ReducerVisitor();\n\n        var expression = visitor.visitLambda(predicate, ...parameters);\n\n        if (visitor.isSolvable == true) {\n            if (expression != null && expression.type == ExpressionType.Logical)\n                this._groups = Filter.visit(<ILogicalExpression>expression);\n        } else {\n            throw new Error('Predicate is not solvable');\n        }\n    }\n\n    public get groups() {\n        return this._groups;\n    }\n\n    public getUnion() {\n        if (this._groups.length == 0)\n            return new Array<IFilterCriteria>();\n\n        return this.groups.reduce((res, v, idx, arr) => {\n            return new Filter(res.criteria.concat(v.criteria));\n        }).criteria;\n    }\n\n    public getIntersection() {\n        if (this.groups.length == 0)\n            return new Array<IFilterCriteria>();\n\n        return this.groups.reduce((res, v, idx, arr) => {\n            var criteria = res.criteria.filter((criteria) => {\n                for (let crit of v.criteria)\n                    if (criteria.property == crit.property && criteria.operator == crit.operator && criteria.value == crit.value) return true;\n\n                return false;\n            })\n\n            return new Filter(criteria);\n        }).criteria\n    }\n}"]}